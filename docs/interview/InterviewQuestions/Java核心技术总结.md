# Table of Contents

  * [Java基础学习总结](#java基础学习总结)
    * [面向对象三大特性](#面向对象三大特性)
    * [基本数据类型](#基本数据类型)
    * [String及包装类](#string及包装类)
    * [final关键字](#final关键字)
    * [抽象类和接口](#抽象类和接口)
    * [代码块和加载顺序](#代码块和加载顺序)
    * [包、内部类、外部类](#包、内部类、外部类)
    * [异常](#异常)
    * [泛型](#泛型)
    * [Class类和Object类](#class类和object类)
    * [javac和java](#javac和java)
    * [反射](#反射)
    * [枚举类](#枚举类)
    * [序列化](#序列化)
    * [动态代理](#动态代理)
    * [多线程](#多线程)
    * [IO流](#io流)
    * [网络编程](#网络编程)
    * [Java8](#java8)



---
title: Java核心技术学习总结
date: 2018-07-10 22:37:47
tags:
    - Java基础
categories:
	- 后端
	- Java基础
---
本文主要是我最近复习Java基础原理过程中写的Java基础学习总结。Java的知识点其实非常多，并且有些知识点比较难以理解，有时候我们自以为理解了某些内容，其实可能只是停留在表面上，没有理解其底层实现原理。

纸上得来终觉浅，绝知此事要躬行。笔者之前对每部分的内容
对做了比较深入的学习以及代码实现，基本上比较全面地讲述了每一个Java基础知识点，当然可能有些遗漏和错误，还请读者指正。

<!-- more -->

**这里先把整体的学习大纲列出来，让大家对知识框架有个基本轮廓，具体每个部分的内容，笔者都对应写了一篇博文来加以讲解和剖析，并且发表在我的个人博客和csdn技术专栏里，下面给出地址**


专栏：深入理解Java原理

https://blog.csdn.net/column/details/21930.html

相关代码实现在我的GitHub里：

https://github.com/h2pl/MyTech

**喜欢的话麻烦star一下哈**

本系列技术文章首发于我的个人博客：

https://h2pl.github.io

更多关于Java后端学习的内容请到我的CSDN博客上查看：

https://blog.csdn.net/a724888

## Java基础学习总结

每部分内容会重点写一些常见知识点，方便复习和记忆，但是并不是全部内容，详细的内容请参见具体的文章地址。

### 面向对象三大特性

    继承：一般类只能单继承，内部类实现多继承，接口可以多继承
    
    封装：访问权限控制public > protected > 包 > private 内部类也是一种封装
    
    多态：编译时多态，体现在向上转型和向下转型，通过引用类型判断调用哪个方法（静态分派）。
    
    运行时多态，体现在同名函数通过不同参数实现多种方法（动态分派）。

### 基本数据类型

    基本类型位数，自动装箱，常量池
    
    例如byte类型是1byte也就是8位，可以表示的数字是-128到127，因为还有一个0，加起来一共是256，也就是2的八次方。
    
    32位和64位机器的int是4个字节也就是32位，char是1个字节就是8位，float是4个字节，double是8个字节，long是8个字节。
    
    所以它们占有字节数是相同的，这样的话两个版本才可以更好地兼容。（应该）
    
    基本数据类型的包装类只在数字范围-128到127中用到常量池，会自动拆箱装箱，其余数字范围的包装类则会新建实例

### String及包装类

    String类型是final类型，在堆中分配空间后内存地址不可变。
    
    底层是final修饰的char[]数组，数组的内存地址同样不可变。
    
    但实际上可以通过修改char[n] = 'a'来进行修改，不会改变String实例的内存值，不过在jdk中，用户无法直接获取char[]，也没有方法能操作该数组。
    所以String类型的不可变实际上也是理论上的不可变。所以我们在分配String对象以后，如果将其 = "abc"，那也只是改变了引用的指向，实际上没有改变原来的对象。
    
    StringBuffer和StringBuilder底层是可变的char[]数组，继承父类AbstractStringBuilder的各种成员和方法，实际上的操作都是由父类方法来完成的。

### final关键字

    final修饰基本数据类型保证不可变
    
    final修饰引用保证引用不能指向别的对象，否则会报错。
    
    final修饰类，类的实例分配空间后地址不可变，子类不能重写所有父类方法。因此在cglib动态代理中，不能为一个类的final修饰的函数做代理，因为cglib要将被代理的类设置为父类，然后再生成字节码。
    
    final修饰方法，子类不能重写该方法。

### 抽象类和接口

    1 抽象类可以有方法实现。
    抽象类可以有非final成员变量。
    抽象方法要用abstract修饰。
    抽象类可以有构造方法，但是只能由子类进行实例化。
    
    2 接口可以用extends加多个接口实现多继承。
    接口只能有public final类型的成员变量。
    接口只能有抽象方法，不能有方法体、
    接口不能实例化，但是可以作为引用类型。

### 代码块和加载顺序

    假设该类是第一次进行实例化。那么有如下加载顺序
    静态总是比非静态优先，从早到晚的顺序是：
    1 静态代码块 和 静态成员变量的顺序根据代码位置前后来决定。
    2 代码块和成员变量的顺序也根据代码位置来决定
    3 最后才调用构造方法构造方法
### 包、内部类、外部类
    1 Java项目一般从src目录开始有com.*.*.A.java这样的目录结构。这就是包结构。所以一般编译后的结构是跟包结构一模一样的，这样的结构保证了import时能找到正确的class引用包访问权限就是指同包下的类可见。
    
    import 一般加上全路径，并且使用.*时只包含当前目录的所有类文件，不包括子目录。
    
    2 外部类只有public和default两种修饰，要么全局可访问，要么包内可访问。
    
    3 内部类可以有全部访问权限，因为它的概念就是一个成员变量，所以访问权限设置与一般的成员变量相同。
    
    非静态内部类是外部类的一个成员变量，只跟外部类的实例有关。
    
    静态内部类是独立于外部类存在的一个类，与外部类实例无关，可以通过外部类.内部类直接获取Class类型。

### 异常

    1 异常体系的最上层是Throwable类
    子类有Error和Exception
    Exception的子类又有RuntimeException和其他具体的可检查异常。
    
    2 Error是jvm完全无法处理的系统错误，只能终止运行。
    
    运行时异常指的是编译正确但运行错误的异常，如数组越界异常，一般是人为失误导致的，这种异常不用try catch，而是需要程序员自己检查。
    
    可检查异常一般是jvm处理不了的一些异常，但是又经常会发生，比如Ioexception，Sqlexception等，是外部实现带来的异常。
    
    3 多线程的异常流程是独立的，互不影响。
    大型模块的子模块异常一般需要重新封装成外部异常再次抛出，否则只能看到最外层异常信息，难以进行调试。
    
    日志框架是异常报告的最好帮手，log4j，slf4j中，在工作中必不可少。

### 泛型

    Java中的泛型是伪泛型，只在编译期生效，运行期自动进行泛型擦除，将泛型替换为实际上传入的类型。
    
    泛型类用class <T> A {
        
    }这样的形式表示，里面的方法和成员变量都可以用T来表示类型。泛型接口也是类似的，不过泛型类实现泛型接口时可以选择注入实际类型或者是继续使用泛型。
    
    泛型方法可以自带泛型比如void <E> E go();
    
    泛型可以使用?通配符进行泛化 Object<?>可以接受任何类型
    
    也可以使用 <? extends Number> <? super Integer>这种方式进行上下边界的限制。

### Class类和Object类

    Java反射的基础是Class类，该类封装所有其他类的类型信息，并且在每个类加载后在堆区生成每个类的一个Class<类名>实例，用于该类的实例化。
    
    Java中可以通过多种方式获取Class类型，比如A.class,new A().getClass()方法以及Class.forName("com.?.?.A")方法。
    
    Object是所有类的父类，有着自己的一些私有方法，以及被所有类继承的9大方法。
    
    有人讨论Object和Class类型谁先加载谁后加载，因为每个类都要继承Object，但是又得先被加载到堆区，事实上，这个问题在JVM初始化时就解决了，没必要多想。

### javac和java

    javac 是编译一个java文件的基本命令，通过不同参数可以完成各种配置，比如导入其他类，指定编译路径等。
    
    java是执行一个java文件的基本命令，通过参数配置可以以不同方式执行一个java程序或者是一个jar包。
    
    javap是一个class文件的反编译程序，可以获取class文件的反编译结果，甚至是jvm执行程序的每一步代码实现。


​    

### 反射

    Java反射包reflection提供对Class，Method，field，constructor等信息的封装类型。
    
    通过这些api可以轻易获得一个类的各种信息并且可以进行实例化，方法调用等。
    
    类中的private参数可以通过setaccessible方法强制获取。
    
    反射的作用可谓是博大精深，JDK动态代理生成代理类的字节码后，首先把这个类通过defineclass定义成一个类，然后用class.for(name)会把该类加载到jvm，之后我们就可以通过，A.class.GetMethod()获取其方法，然后通过invoke调用其方法，在调用这个方法时，实际上会通过被代理类的引用再去调用原方法。

### 枚举类

    枚举类继承Enum并且每个枚举类的实例都是唯一的。
    
    枚举类可以用于封装一组常量，取值从这组常量中取，比如一周的七天，一年的十二个月。
    
    枚举类的底层实现其实是语法糖，每个实例可以被转化成内部类。并且使用静态代码块进行初始化，同时保证内部成员变量不可变。

### 序列化

    序列化的类要实现serializable接口
    
    transient修饰符可以保证某个成员变量不被序列化
    
    readObject和writeOject来实现实例的写入和读取。
    
    待更新。
    
    事实上，一些拥有数组变量的类都会把数组设为transient修饰，这样的话不会对整个数组进行序列化，而是利用专门的方法将有数据的数组范围进行序列化，以便节省空间。

### 动态代理

    jdk自带的动态代理可以代理一个已经实现接口的类。
    
    cglib代理可以代理一个普通的类。
    
    动态代理的基本实现原理都是通过字节码框架动态生成字节码，并且在用defineclass加载类后，获取代理类的实例。
    
    一般需要实现一个代理处理器，用来处理被代理类的前置操作和后置操作。在JDK动态代理中，这个类叫做invocationHandler。
    
    JDK动态代理首先获取被代理类的方法，并且只获取在接口中声明的方法，生成代理类的字节码后，首先把这个类通过defineclass定义成一个类，然后把该类加载到jvm，之后我们就可以通过，A.class.GetMethod()获取其方法，然后通过invoke调用其方法，在调用这个方法时，实际上会通过被代理类的引用再去调用原方法。
    
    而对于cglib动态代理，一般会把被代理类设为代理类的父类，然后获取被代理类中所有非final的方法，通过asm字节码框架生成代理类的字节码，这个代理类很神奇，他会保留原来的方法以及代理后的方法，通过方法数组的形式保存。
    
    cglib的动态代理需要实现一个enhancer和一个interceptor，在interceptor中配置我们需要的代理内容。如果没有配置interceptor，那么代理类会调用被代理类自己的方法，如果配置了interceptor，则会使用代理类修饰过的方法。


### 多线程
    这里先不讲juc包里的多线程类。juc相关内容会在Java并发专题讲解。
    
    线程的实现可以通过继承Thread类和实现Runable接口
    也可以使用线程池。callable配合future可以实现线程中的数据获取。
    
    Java中的线程有7种状态，new runable running blocked waiting time_waiting terminate
    blocked是线程等待其他线程锁释放。
    waiting是wait以后线程无限等待其他线程使用notify唤醒
    time_wating是有限时间地等待被唤醒，也可能是sleep固定时间。
    
    Thread的join是实例方法，比如a.join(b),则说明a线程要等b线程运行完才会运行。
    
    o.wait方法会让持有该对象o的线程释放锁并且进入阻塞状态，notify则是持有o锁对象的线程通知其他等待锁的线程获取锁。notify方法并不会释放锁。注意这两个方法都只能在synchronized同步方法或同步块里使用。
    
    synchronized方法底层使用系统调用的mutex锁，开销较大，jvm会为每个锁对象维护一个等待队列，让等待该对象锁的线程在这个队列中等待。当线程获取不到锁时则让线程阻塞，而其他检查notify以后则会通知任意一个线程，所以这个锁时非公平锁。
    
    Thread.sleep()，Thread.interrupt()等方法都是类方法，表示当前调用该方法的线程的操作。


​    
    一个线程实例连续start两次会抛异常,这是因为线程start后会设置标识，如果再次start则判断为错误。

### IO流

    IO流也是Java中比较重要的一块，Java中主要有字节流，字符流，文件等。其中文件也是通过流的方式打开，读取和写入的。
    
    IO流的很多接口都使用了装饰者模式，即将原类型通过传入装饰类构造函数的方式，增强原类型，以此获得像带有缓冲区的字节流，或者将字节流封装成字符流等等，其中需要注意的是编码问题，后者打印出来的结果可能是乱码哦。
    
    IO流与网络编程息息相关，一个socket接入后，我们可以获取它的输入流和输出流，以获取TCP数据包的内容，并且可以往数据报里写入内容，因为TCP协议也是按照流的方式进行传输的，实际上TCP会将这些数据进行分包处理，并且通过差错检验，超时重传，滑动窗口协议等方式，保证了TCP数据包的高效和可靠传输。

### 网络编程

    承接IO流的内容
    
    IO流与网络编程息息相关，一个socket接入后，我们可以获取它的输入流和输出流，以获取TCP数据包的内容，并且可以往数据报里写入内容，因为TCP协议也是按照流的方式进行传输的，实际上TCP会将这些数据进行分包处理，并且通过差错检验，超时重传，滑动窗口协议等方式，保证了TCP数据包的高效和可靠传输。
    
    除了使用socket来获取TCP数据包外，还可以使用UDP的DatagramPacket来封装UDP数据包，因为UDP数据包的大小是确定的，所以不是使用流方式处理，而是需要事先定义他的长度，源端口和目标端口等信息。
    
    为了方便网络编程，Java提供了一系列类型来支持网络编程的api，比如URL类，InetAddress类等。
    
    后续文章会带来NIO相关的内容，敬请期待。


​    


### Java8

    接口中的默认方法，接口终于可以有方法实现了，使用注解即可标识出默认方法。
    
    lambda表达式实现了函数式编程，通过注解可以声明一个函数式接口，该接口中只能有一个方法，这个方法正是使用lambda表达式时会调用到的接口。
    
    Option类实现了非空检验
    
    新的日期API
    
    各种api的更新，包括chm，hashmap的实现等
    
    Stream流概念，实现了集合类的流式访问，可以基于此使用map和reduce并行计算。




